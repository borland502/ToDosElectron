# Setting up Debugging for TypeScript Electron application

The [last post](https://jdunkerley.co.uk/2017/06/03/how-to-set-up-webpack-based-typescript-electron-react-build-process-with-vsts-ci/) covered the basic set up of TypeScript Electron application being build by WebPack. This post follows on with a couple of extra features.

## Multiple Renderer Entry Points

The current set up builds `src\gui.tsx` into the main entry point of the renderer process (`dist\index.html`). The first change is to add a function which finds all the `tsx` files in the `src` directory. Unlike the test config, it shouldn't scan sub-folders allowing for components to be in there:

``` javascript
const fs = require('fs')

const guiEntries =
  fs.readdirSync('src')
    .filter(f => f.match(/.*\.tsx$/))
    .map(f => path.join('src', f))
    .reduce((memo, file) => {
      memo[path.basename(file, path.extname(file))] = path.resolve(file)
      return memo
    }, {})
```

This code will create a dictionary of entry points of all `tsx` files. This can be used in the `electron-renderer` target setting replacing `entry: { gui: './src/gui.tsx' },` with `entry: guiEntries,`. Rebuilding the project now produces the same output as before. Add a new file `src/secondui.tsx`:

``` javascript
import React from 'react'
import ReactDOM from 'react-dom'

ReactDOM.render(
  <div>Electron version: {process.versions.electron}</div>,
  document.getElementsByTagName('body')[0])

```

Rebuild the project and a new `dist/secondui.js` file will be created. There is however only one html file generated by `HtmlWebpackPlugin`. In order to make this plugin build multiple html files, there needs to be a plugiin for each entry. Using the `map` function on the `guiEntries` replace the plugins with:

``` javascript
plugins: Object.keys(guiEntries).map(k => new HtmlWebpackPlugin({ filename: `${k}.html`, chunks: [k]}))
```

Re-running the build again and in the `dist` file there should be:

- `gui.html`
- `gui.js`
- `secondui.html`
- `secondui.js`
- `main.js`

As the build has already been run there will also be `index.html` file. There is a plug in for WebPack which will clean out folders before building. Run

```
yarn add -D clean-webpack-plugin
```

and then add:

``` javascript
const CleanWebpackPlugin = require('clean-webpack-plugin')
```

to the top of the `webpack.config.js` and alter the `plugins` to be:

``` javascript
      plugins: [
        new CleanWebpackPlugin(['dist'], { exclude: ['main.js'] }),
        ...Object.keys(guiEntries).map(k => new HtmlWebpackPlugin({ filename: `${k}.html`, chunks: [k] }))
      ]
```

(the new ... spread operator is fantastic!)

The first setting on `CleanWebpackPlugin` tells it which folders to clean. The second is a set of options, in this case telling it to ignore the output of the parallel build process.

## Visual Studio Code Debugging

In order to help with debugging want the build process to output sourcemap files. The `tsconfig.json` already has the option set on it to produce them but they are not being written out. To make webpack write the sourcemap files add a `SourceMapDevToolPlugin` to both build configs. The final `module.exports` looks like:

``` javascript
module.exports = [
  Object.assign(
    {
      target: 'electron-main',
      entry: { main: './src/main.ts' },
      plugins: [ new webpack.SourceMapDevToolPlugin({ filename: '[name].js.map' }) ]
    },
    commonConfig),
  Object.assign(
    {
      target: 'electron-renderer',
      entry: guiEntries,
      plugins: [
        new CleanWebpackPlugin(['dist'], { exclude: ['main.js'] }),
        new webpack.SourceMapDevToolPlugin({ filename: '[name].js.map' }),
        ...Object.keys(guiEntries).map(k => new HtmlWebpackPlugin({ filename: `${k}.html`, chunks: [k] }))
      ]
    },
    commonConfig)
]
```

## Visual Studio Team Services Build Badge